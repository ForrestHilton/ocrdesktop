#!/bin/python3
# -*- coding: utf-8 -*-


"""OCRdesktop"""

__version__   = "0.9.86"
__copyright__ = "Copyright (c) 2015 Chrys"
__license__   = "LGPL"
__authors__   = ["chrys"]
__website__   = "https://github.com/chrys87/ocrdesktop"
__appname__   = "OCRdesktop"
__comments__  = "A accessibility tool for woring with inaccessible windows and dialogs"
#Python Utils
import os, sys, getopt, locale, time, re, _thread, shutil
from PIL import Image

#tesseract
from tesserwrap import tesseract

#gi
import gi

#GTK/GDK/Wnck/GObject
gi.require_version("Gtk", "3.0")
gi.require_version("Gdk", "3.0")
gi.require_version("Wnck", "3.0")
from gi.repository import Gtk, Gdk, GObject, Wnck


# AT-SPI
import pyatspi

KEY_CODE = {
    '1': 10, '2': 11, '3': 12, '4': 13, '5': 14, '6': 15,
    '7': 16, '8': 17, '9': 18, '0': 19, 'dash': 20, '=': 21,
    'q': 24, 'w': 25, 'e': 26, 'r': 27, 't': 28, 'y': 29,
    'u': 30, 'i': 31, 'o': 32, 'p': 33, '[': 34, ']': 35,
    'a': 38, 's': 39, 'd': 40, 'f': 41, 'g': 42, 'h': 43,
    'j': 44, 'k': 45, 'l': 46, ';': 47, 'z': 52, 'x': 53,
    'c': 54, 'v': 55, 'b': 56, 'n': 57, 'm': 58, ',': 59,
    '.': 60, '/': 61, '\'': 48, '\\': 51, '`': 49, '|': 52,
    'esc': 9, 'back': 22, 'enter': 36, 'space': 65, 'tab': 23,
    'ins': 118, 'del': 119, 'home': 110, 'end': 115, 'pgup': 112,
    'pgdown': 117, 'up': 111, 'left': 113, 'right': 114, 'down': 116,
    'f1': 67, 'f2': 68, 'f3': 69, 'f4': 70,
    'f5': 71, 'f6': 72, 'f7': 73, 'f8': 74,
    'f9': 75, 'f10': 76, 'f11': 95, 'f12': 96,
    'alt': 64,
    'alt_r': 105,
    'ctrl': 37,
    'ctrl_r': 108,
    'shift': 50,
    'shift_r': 62,
    'super': 133,
    'caps': 66,
    'menu': 135,
    'pause': 127,
    'num_lock': 77,
    'scroll_lock': 78,
    }


# here the class
class OCRNavigation(Gtk.Window):
	def __init__(self, debug_p = False):
		self._debug = debug_p
		self._tree = None
		self._textbox = None
		self._textbuffer = None
		self._closeButton = None
		self._rightClickButton = None
		self._leftClickButton = None
		self._leftDoubleClickButton = None	
		self._middleClickButton = None
		self._routeToPointButton = None
		self._saveToMacroButton = None
		self._viewButton = None
		self._viewMode = 0
		self._screenShotMode = 0 # 0 = Window; 1 = Desktop
		self._sendToClipboard = False
		self._hideGui = False
		self._saveToMacro = False
		self._scrolledWindowTree = None
		self._scrolledWindowText = None
		self._grid = None
		self._menubar = None
		self._font_button = None
		self._accelerators = None
		self._OCRWords = None		
		self._OCRWordList = []
		self._OCRText = ''
		self._img = None
		self._scaleFactor = 3
		self._offsetXpos = 0
		self._offsetYpos = 0
		self.GTKmainIsRunning = False
		locale.setlocale(locale.LC_NUMERIC, 'C') #needed by tesseract in non english languages 
		self._macro = OCRMacroManager()
		self._tess = tesseract("/usr/share")
		
	def _setHideGui(self, hideGui_p):
		self.hideGui = hideGui_p
		
	def _setSendToClipboard(self, sendToClipboard_p):
		self._sendToClipboard = sendToClipboard_p
		
	def _setScreenShotMode(self, screenShotMode_p):
		self._screenShotMode = screenShotMode_p

	def _setMacro(self, macro_p):
		self._macro = macro_p
		
	def _screenShotDesktop(self):
		CurrDesktop = Gdk.get_default_root_window()	
		pixBuff = Gdk.pixbuf_get_from_window(CurrDesktop, 0, 0, CurrDesktop.get_width(), CurrDesktop.get_height())
		if (pixBuff != None):
			self._img = self.pixbuf2image(pixBuff)
			if self._debug: # Debug code
				self._img.save("/tmp/ocrScreenshot.png") 
				print("save screenshot:/tmp/ocrScreenshot.png") 
			self._scaleImg()
			return True
		else:
			if self._debug: # Debug code
				print("Could not take screenshot") 
			return False

	def _screenShotWindow(self): #Mode=0 Desktop  Mode=1 CurrWindow
		Gtk.main_iteration_do(False) # workarround segfault
		gdkCurrDesktop = Gdk.get_default_root_window()
		currWnckScreen = Wnck.Screen.get_default()
		currWnckScreen.force_update()
		currWnckWindow = currWnckScreen.get_active_window()
		self._offsetXpos, self._offsetYpos, wnckWidth, wnckHeight = Wnck.Window.get_geometry(currWnckWindow)
		pixBuff = Gdk.pixbuf_get_from_window(gdkCurrDesktop, self._offsetXpos, self._offsetYpos , wnckWidth, wnckHeight)
		if self._debug:
			pixBuff.savev('/tmp/ocrpixBuff.bmp', 'bmp', [], []) # Debug code
			print("save pixBuff /tmp/ocrpixBuff.bmp")
		if (pixBuff != None):
			self._img = self.pixbuf2image(pixBuff)
			if self._debug: # Debug code
				self._img.save("/tmp/ocrScreenshot.png") 
				print("save screenshot:/tmp/ocrScreenshot.png") 
			self._scaleImg()
			return True
		else:
			if self._debug: # Debug code
				print("Could not take screenshot") 
			return False

	def pixbuf2image(self, pix):
		"""Convert gdkpixbuf to PIL image"""
		data = pix.get_pixels()
		w = pix.props.width
		h = pix.props.height
		stride = pix.props.rowstride
		mode = "RGB"
		if pix.props.has_alpha == True:
			mode = "RGBA"
		im = Image.frombytes(mode, (w, h), data, "raw", mode, stride)
		return im

	def _scaleImg(self):
		width_screen, height_screen = self._img.size
		width_screen =  width_screen * self._scaleFactor
		height_screen = height_screen * self._scaleFactor
		self._img = self._img.resize( (width_screen, height_screen), Image.BICUBIC)
		if self._debug: # Debug code
			self._img.save("/tmp/ocrScreenshotScaled.png")
			print("save scaled screenshot:/tmp/ocrScreenshotScaled.png")


	def _screenShot(self):
		Ok = False
		if self._screenShotMode == 0:
			Ok = self._screenShotWindow()
		elif self._screenShotMode == 1:
			Ok = self._screenShotDesktop()
			
		return Ok
				
	def _ocrImage(self):
		if self._img is None:
			return False
				
		self._OCRText = self._tess.ocr_image(self._img)
		regexSpace = re.compile('[^\S\r\n]{2,}') #remove double spaces
#		regexSpace = re.compile('[\s]{2,}') #remove double spaces
		self._OCRText = regexSpace.sub(' ',self._OCRText)
		regexSpace = re.compile('\n\s*\n') #remove empty lines
		self._OCRText = regexSpace.sub('\n',self._OCRText)
		regexSpace = re.compile('\s*\n') #remove ending spaces
		self._OCRText = regexSpace.sub('\n',self._OCRText)
		regexSpace = re.compile('\n\s') #remove trailing spaces
		self._OCRText = regexSpace.sub( '\n', self._OCRText)
		regexSpace = re.compile('^\s') #remove trailing space in first line
		self._OCRText = regexSpace.sub( '\n', self._OCRText)
		regexSpace = re.compile('$\n') #remove ending newline
		self._OCRText = regexSpace.sub( '', self._OCRText)
		if self._sendToClipboard:
			self._setTextToClipboard( self._OCRText)
		if not self._hideGui:
			self._OCRWords = self._tess.get_words()
			self._fillOCRWordlist()
		return True

	def _fillOCRWordlist(self):
		for OCRWord in self._OCRWords: # fill the list
			#regexSpace = re.compile('[\s\t\r\n*]') #remove empty lines
			#tmpOCRText = regexSpace.sub('',self._OCRText)
			if int(OCRWord.confidence) != 0:
				self._OCRWordList.append([OCRWord.value.decode("utf-8"),int((OCRWord.box[2] - OCRWord.box[0]) / 2 + OCRWord.box[0]),int((OCRWord.box[3] - OCRWord.box[1]) / 2 + OCRWord.box[1]),int(OCRWord.confidence)])

	def add_accelerator(self, widget, accelerator, signal="activate"):
		"""Adds a keyboard shortcut"""
		if accelerator is not None:
			key, mod = Gtk.accelerator_parse(accelerator)
			widget.add_accelerator(signal, self._accelerators, key, mod, Gtk.AccelFlags.VISIBLE)

	def on_font_set(self, widget):
		font_description = widget.get_font_desc()
		self._textbox.modify_font(font_description)
	
	def _createNavListDialog(self):
		Gtk.Window.__init__(self, title="OCR")
		self.set_default_size(700,700)

		self._scrolledWindowText = Gtk.ScrolledWindow()

		self._textbox = Gtk.TextView()
		self._textbox.set_hexpand(True)
		self._textbox.set_vexpand(True)
		self._textbuffer = self._textbox.get_buffer()
		self._textbuffer.set_text(self._OCRText)
		self._textbox.set_editable(False)
		if not self._textbuffer.get_start_iter() is None:
			self._textbuffer.place_cursor(self._textbuffer.get_start_iter())
		self._scrolledWindowText.add(self._textbox)
		
		self._accelerators = Gtk.AccelGroup()

		self._menubar = Gtk.MenuBar()

		self.menu_ocrdesktop = Gtk.Menu()
		self.item_toggleview = Gtk.MenuItem("Toggle _View")
		self.item_toggleview.set_use_underline(True)
		self.add_accelerator(self.item_toggleview, "<Control>v","activate")
		self.item_clipboard = Gtk.MenuItem("Send to _Clipboard")
		self.item_clipboard.set_use_underline(True)
		self.add_accelerator(self.item_clipboard, "<Control>c","activate")
		self.item_font = Gtk.MenuItem("_Font")
		self.item_font.set_use_underline(True)
		self.item_close = Gtk.MenuItem("_Close")
		self.add_accelerator(self.item_close, "<Control>q","activate")
		self.item_close.set_use_underline(True)
		self.menu_ocrdesktop.append(self.item_toggleview)
		self.menu_ocrdesktop.append(self.item_clipboard)
		#self.menu_ocrdesktop.append(self.item_font)
		self.menu_ocrdesktop.append(self.item_close)
		self.item_toggleview.connect("activate", self._toggleView)
		self.item_clipboard.connect("activate", self._onSetTextToClipboard, self._OCRText)
		self.item_close.connect("activate", Gtk.main_quit)
		
		self.menu_interact = Gtk.Menu()
		self.item_preclick = Gtk.MenuItem("_Preclick")
		self.item_preclick.set_use_underline(True)
		self.add_accelerator(self.item_preclick, "<Control>p","activate")
		self.item_leftclick = Gtk.MenuItem("_Left Click")
		self.item_leftclick.set_use_underline(True)
		self.add_accelerator(self.item_leftclick, "<Control>l","activate")
		self.item_doubletclick = Gtk.MenuItem("_Double Click")
		self.item_doubletclick.set_use_underline(True)
		self.add_accelerator(self.item_doubletclick, "<Control>d","activate")
		self.item_rightclick = Gtk.MenuItem("_Right Click")
		self.item_rightclick.set_use_underline(True)
		self.add_accelerator(self.item_rightclick, "<Control>r","activate")
		self.item_middleclick = Gtk.MenuItem("_Middle Click")
		self.item_middleclick.set_use_underline(True)
		self.add_accelerator(self.item_middleclick, "<Control>m","activate")
		self.item_routeto = Gtk.MenuItem("Route _To")
		self.item_routeto.set_use_underline(True)
		self.add_accelerator(self.item_routeto, "<Control>t","activate")
		self.item_sendkey = Gtk.MenuItem("Send _Key")
		self.item_sendkey.set_use_underline(True)
		self.add_accelerator(self.item_sendkey, "<Control>k","activate")
		self.menu_interact.append(self.item_preclick)
		self.menu_interact.append(self.item_leftclick)
		self.menu_interact.append(self.item_doubletclick)
		self.menu_interact.append(self.item_rightclick)
		self.menu_interact.append(self.item_middleclick)
		self.menu_interact.append(self.item_routeto)
		self.menu_interact.append(self.item_sendkey)
		self.item_preclick.connect("activate", self._setSaveToMacro)
		self.item_leftclick.connect("activate", self._onLeftClick)
		self.item_doubletclick.connect("activate", self._onDoubleLeftClick)
		self.item_rightclick.connect("activate", self._onRightClick)
		self.item_middleclick.connect("activate", self._onMiddleClick)
		self.item_routeto.connect("activate", self._routeToPoint)
		
		self.menu_macro = Gtk.Menu()
		self.item_save = Gtk.MenuItem("_Save As")
		self.item_save.set_use_underline(True)
		self.add_accelerator(self.item_save, "<Control>s","activate")
		self.item_load = Gtk.MenuItem("_Load")
		self.item_load.set_use_underline(True)
		self.add_accelerator(self.item_load, "<Control>o","activate")
		self.item_delete = Gtk.MenuItem("_Unload")
		self.item_delete.set_use_underline(True)
		self.add_accelerator(self.item_delete, "<Control>u","activate")
		self.item_run = Gtk.MenuItem("_Run")
		self.item_run.set_use_underline(True)
		self.add_accelerator(self.item_run, "<Control>n","activate")
		self.menu_macro.append(self.item_save)
		self.menu_macro.append(self.item_load)
		self.menu_macro.append(self.item_delete)
		self.menu_macro.append(self.item_run)
		self.item_save.connect("activate", self._macro._saveMacro, self)
		self.item_load.connect("activate", self._macro._onLoadMacro, self)
		self.item_delete.connect("activate", self._macro._onDeleteMacro, False)
		self.item_run.connect("activate", self._onRunMacro)
		
		self.menu_help = Gtk.Menu()
		self.item_about = Gtk.MenuItem("_About")
		self.item_about.set_use_underline(True)	
		self.menu_help.append(self.item_about)
		self.item_about.connect("activate", self._onRunAboutDialog, self)

		self.item_ocrdesktop = Gtk.MenuItem("_OCRdektop")
		self.item_ocrdesktop.set_use_underline(True)
		self.item_interact = Gtk.MenuItem("_Interact")
		self.item_interact.set_use_underline(True)
		self.item_macro = Gtk.MenuItem("_Macro")
		self.item_macro.set_use_underline(True)
		self.item_help = Gtk.MenuItem("_Help")
		self.item_help.set_use_underline(True)

		self.item_ocrdesktop.set_submenu(self.menu_ocrdesktop)
		self.item_interact.set_submenu(self.menu_interact)
		self.item_macro.set_submenu(self.menu_macro)
		self.item_help.set_submenu(self.menu_help)
		self._menubar.append(self.item_ocrdesktop)
		self._menubar.append(self.item_interact)
		self._menubar.append(self.item_macro)
		self._menubar.append(self.item_help)
		self.add_accel_group(self._accelerators)

		self._scrolledWindowTree = Gtk.ScrolledWindow()

		self._tree = Gtk.TreeView()
		self._tree.set_hexpand(True)
		self._tree.set_vexpand(True)
		self._scrolledWindowTree.add(self._tree)

		cols = [GObject.TYPE_STRING]
		cols.extend([GObject.TYPE_STRING])
		cols.extend([GObject.TYPE_INT])
		cols.extend([GObject.TYPE_INT])
		cols.extend([GObject.TYPE_INT])
		model = Gtk.ListStore(*cols)
		self._tree.set_model(model)
		columnHeaders = ['OCR Text','X Position','Y Position','Confidence']

		cell = Gtk.CellRendererText()
		column = Gtk.TreeViewColumn("OCR Text", cell, text=0)
		column.set_visible(False)
		self._tree.append_column(column)

		for i, header in enumerate(columnHeaders):
			cell = Gtk.CellRendererText()
			column = Gtk.TreeViewColumn(header, cell, text=i+1)
			#column.set_sort_column_id(i+1)
			self._tree.append_column(column)

		model = self._tree.get_model()
		for row in self._OCRWordList:
			rowIter = model.append(None)
			i = 0
			for cell in row:
				i = i + 1
				if i == 2:
					cell = cell / self._scaleFactor + self._offsetXpos
				if i == 3:
					cell = cell / self._scaleFactor + self._offsetYpos
				model.set_value(rowIter, i, cell)

		self._tree.set_search_column(1)

		self._font_button = Gtk.FontButton()
		self._font_button.connect('font-set', self.on_font_set)

		self._closeButton = Gtk.Button("_Close")
		self._closeButton.set_use_underline(True)
		self._closeButton.connect("clicked", Gtk.main_quit)

		self._viewButton = Gtk.Button("Toggle _View")
		self._viewButton.set_use_underline(True)
		self._viewButton.connect("clicked", self._toggleView)

		self.connect("delete-event", Gtk.main_quit)

		self._leftClickButton = Gtk.Button("_Left Click")
		self._leftClickButton.set_use_underline(True)
		self._leftClickButton.connect("clicked", self._onLeftClick)

		self._rightClickButton = Gtk.Button("_Right Click")
		self._rightClickButton.set_use_underline(True)
		self._rightClickButton.connect("clicked", self._onRightClick)

		self._leftDoubleClickButton = Gtk.Button("_Double Click")
		self._leftDoubleClickButton.set_use_underline(True)
		self._leftDoubleClickButton.connect("clicked", self._onDoubleLeftClick)

		self._middleClickButton = Gtk.Button("_Middle Click")
		self._middleClickButton.set_use_underline(True)
		self._middleClickButton.connect("clicked", self._onMiddleClick)

		self._routeToPointButton = Gtk.Button("Route _To")
		self._routeToPointButton.set_use_underline(True)
		self._routeToPointButton.connect("clicked", self._routeToPoint)

		self._saveToMacroButton = Gtk.CheckButton("Sa_ve as Preclick")
		self._saveToMacroButton.set_use_underline(True)
		self._saveToMacroButton.connect("toggled", self._setSaveToMacro)

		self.connect('key-release-event', self._onKeyRelease)
		#self._textbuffer.connect("notify::cursor-position", self._onCursorTextPositionChanged)
		#self._tree.connect("notify::cursor-position", self._onCursorTreePositionChanged)
		
		self._grid = Gtk.Grid()
		self._grid.attach(self._menubar,0,0,10,1)
		self._grid.attach(self._scrolledWindowTree, 0, 1, 10, 10)
		self._grid.attach(self._scrolledWindowText, 0, 1, 10, 10)
		self._grid.attach(self._font_button, 0, 11, 1, 3)
#		self._grid.attach(self._saveToMacroButton, 1, 11, 1, 1)
#		self._grid.attach(self._leftClickButton, 2, 11, 1, 1)
#		self._grid.attach(self._leftDoubleClickButton, 3, 11, 1, 1)
#		self._grid.attach(self._rightClickButton, 4, 11, 1, 1)
#		self._grid.attach(self._middleClickButton, 5, 11, 1, 1)
#		self._grid.attach(self._routeToPointButton, 6, 11, 1, 1)
#		self._grid.attach(self._closeButton, 7, 11, 1, 1)
		self.add(self._grid)

	def _onCursorTextPositionChanged(self, widget, event):
		#print(widget.props.cursor_position)
		#position = widget.get_iter_at_offset(widget.props.cursor_position)
		#if not widget.get_start_iter() is None:
		#	print(widget.get_text(widget.get_start_iter(),position,False).count('\n')+widget.get_text(widget.get_start_iter(),position,True).count(' '))
#TODO set the pos correct		
	#wtf is thist not working		self._tree.set_cursor(widget.get_text(widget.get_start_iter(),position,True).count('\n')+widget.get_text(widget.get_start_iter(),position,True).count(' '))
		pass

	def _onCursorTreePositionChanged(self, widget, event):
#TODO set the pos correct
		#print(widget.props.cursor_position)
		#position = widget.get_iter_at_offset(widget.props.cursor_position)
		#if not widget.get_start_iter() is None:
		#	print(widget.get_text(widget.get_start_iter(),position,False).count('\n')+widget.get_text(widget.get_start_iter(),position,True).count(' '))
		#	self._tree.set_cursor(widget.get_text(widget.get_start_iter(),position,True).count('\n')+widget.get_text(widget.get_start_iter(),position,True).count(' '))
		pass

	def _setSaveToMacro(self, widget):
		self._saveToMacro = not self._saveToMacro

	def setFocus(self):
		if self._viewMode == 0:		
			position = self._textbuffer.get_iter_at_offset(self._textbuffer.props.cursor_position)
			if not self._textbuffer.get_start_iter() is None:
				self._tree.set_cursor(self._textbuffer.get_text(self._textbuffer.get_start_iter(),position,True).count('\n')+self._textbuffer.get_text(self._textbuffer.get_start_iter(),position,True).count(' '))

	def showGUI(self):
		self._gui = self._createNavListDialog()
		self.set_modal(True)
		self.show_all()
		self._tree.grab_focus()
		self._scrolledWindowTree.hide()
		self._textbox.grab_focus()
		self.startMain()
		
	def startMain(self):
		self.GTKmainIsRunning = True
		Gtk.main()

	def _onRunAboutDialog(self,widget,window):
		dialog = Gtk.AboutDialog(window)
		dialog.set_authors(__authors__)
		dialog.set_website(__website__)
		dialog.set_copyright(__copyright__)
		dialog.set_license(__license__)
		dialog.set_version(__version__)
		dialog.set_program_name(__appname__)
		dialog.set_comments(__comments__)
		dialog.run()
		dialog.destroy()
		
	def _toggleView(self, widget):
		self.setFocus()
		if self._viewMode == 0:
			self._scrolledWindowText.hide()
			self._scrolledWindowTree.show()
			self._tree.grab_focus()
			self._viewMode = 1
		else:
			self._scrolledWindowText.show()
			self._scrolledWindowTree.hide()
			self._textbox.grab_focus()
			self._viewMode = 0

	def _onKeyRelease(self, widget, event):
		keycode = event.hardware_keycode
		keymap = Gdk.Keymap.get_default()
		entries_for_keycode = keymap.get_entries_for_keycode(keycode)
		entries = entries_for_keycode[-1]
		eventString = Gdk.keyval_name(entries[0])
		if self._debug:
			print(eventString)
#		if eventString == 'Escape':
#			Gtk.main_quit()
#		if eventString == 'Return':
#			self._leftClickButton.grab_focus()

	def _cancel(self):
		if self.GTKmainIsRunning:
			Gtk.main_quit()
			GTKmainIsRunning = False

	def _routeToPoint(self, widget):
		self.setFocus()
		self.hide()
		xpos, ypos = self._getSelectedEntry()
		_thread.start_new_thread( self._threadrouteToPoint, (xpos,ypos, ) )

	def _onRightClick(self, widget):
		self.setFocus()
		xpos, ypos = self._getSelectedEntry()
		self.hide()
		_thread.start_new_thread( self._threadDoClick, (xpos,ypos,"b3c", ) )	

	def _onLeftClick(self, widget):
		self.setFocus()
		xpos, ypos = self._getSelectedEntry()
		self.hide()
		_thread.start_new_thread( self._threadDoClick, (xpos,ypos, "b1c" ) )		

	def _onDoubleLeftClick(self, widget):
		self.setFocus()
		xpos, ypos = self._getSelectedEntry()
		self.hide()
		_thread.start_new_thread( self._threadDoClick, (xpos,ypos,"b1d", ) )	

	def _onMiddleClick(self, widget):
		self.setFocus()
		xpos, ypos = self._getSelectedEntry()
		self.hide()
		_thread.start_new_thread( self._threadDoClick, (xpos,ypos,"b2c", ) )	

	def _threadrouteToPoint(self, xpos=1,ypos=1,delay=0.8, posRelation = "abs"):
		if self._saveToMacro:
			self._macro._writeMouseToMacro(xpos,ypos,'None')
		else:
			time.sleep(delay)
			pyatspi.Registry.generateMouseEvent(xpos,ypos,posRelation)
		self._cancel()
		
	def _onRunMacro(self, widget):
		if self._macro._macroExists():
			self.hide()
			_thread.start_new_thread( self._threadRunMacro, () )
		else:
			dialog = Gtk.MessageDialog(self, 0, Gtk.MessageType.INFO,
				Gtk.ButtonsType.OK, "No Macro loaded")
			dialog.format_secondary_text(
				"You have to load a macro for execution.")
			dialog.run()
			dialog.destroy()	

	def _threadRunMacro(self):
		self._macro._threadRunMacro()	
		self._cancel()

	def _threadDoClick(self, xpos=1,ypos=1,mouseEvent='b1c',delay=0.8, posRelation = "abs"):
		if self._saveToMacro:
			self._macro._writeMouseToMacro(xpos,ypos,mouseEvent)
		else:
			time.sleep(delay)
			pyatspi.Registry.generateMouseEvent(xpos,ypos,posRelation)
			pyatspi.Registry.generateMouseEvent(xpos,ypos,mouseEvent)
		self._cancel()

	def _onSetTextToClipboard(self, widget, text_p):
		self._setTextToClipboard(text_p)

	def _setTextToClipboard(self, text_p):
		ClipboardObj = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
		ClipboardObj.set_text(text_p, -1)
		ClipboardObj.store()

	def _getSelectedEntry(self):
		if not self._tree:
			return None

		selection = self._tree.get_selection()
		if not selection:
			return None

		model, paths = selection.get_selected_rows()
		if not paths:
			return None

		return model.get_value(model.get_iter(paths[0]), 2),model.get_value(model.get_iter(paths[0]), 3)

class OCRScreenReader():
	def __init__(self):
		self._sendToClipboard = False
		self._hideGui = False
		self._screenShotMode = 0 # 0 = Window; 1 = Desktop
		self._macroFile = '/tmp/MyOCRMacro.ocrm'
		self._showHelp = False
		self._debug = False
		self._setCommandLineOptions()

		if self._showHelp:
			return

		#MACRO
		self._macro = OCRMacroManager(self._debug)
		self._macro._loadMcroFile(self._macroFile)
		if not self._hideGui:
			self._macro.showGUI()
		else:
			if self._macro._macroExists():
				self._macro._RunMacro()

		#NAVIGATION
		self._Navigation = OCRNavigation(self._debug)

		self._Navigation._setSendToClipboard(self._sendToClipboard)
		self._Navigation._setScreenShotMode(self._screenShotMode)
		self._Navigation._setHideGui(self._hideGui)
		if self._debug:
			print("PreWaitForFinish")
		self._macro.WaitForFinish()
		self._Navigation._setMacro(self._macro)
		
		if self._Navigation._screenShot():
			self._Navigation._ocrImage()
			if not self._hideGui:
				self._Navigation.showGUI()

		#FUNCTIONS
	def _setCommandLineOptions(self):
		try:
			myopts, args = getopt.getopt(sys.argv[1:],"hpndcm:")
			###############################
			# o == option
			# a == argument passed to the o
			###############################
			for o, a in myopts:
				if o == '-v':
					self._debug = True
					print('Debugmode ON')
				elif o == '-d':
					self._screenShotMode = 1
				elif o == '-c':
					self._sendToClipboard = True
				elif o == '-m':
					self._macroFile = a
				elif o == '-n':
					self._hideGui = True
				elif o == '-h':
					self._printHelp()
		except:
					self._printHelp()

	def _printHelp(self):
		print(__version__)
		print("ocrdesktop -h -p -n -d -c -m")
		print("-h		Print help with start")
		print("-n		hide GUI  (use with -c or -m")
		print("-v		print debug messages")
		print("-d		OCR the Destkop")
		print("-c		Send to Clipboard")
		print("-m <MacroFile>	run a macro before starting.")	
		self._showHelp = True				


class OCRMacroManager:

	def __init__(self,debug_p = False):
		self._cancelButton = None
		self._runMacroButton = None
		self._deleteMacroButton = None
		self._menubar = None
		self._accelerators = None
		self._grid = None
		self._labelAutoClickExists = None
		self._macroFile ='/tmp/MyOCRMacro.ocrm'
		self._gui = None
		self._MacroFinished = False
		self._debug = debug_p
		
	def _loadMcroFile(self, macroFile_p):
		if self._loadMacroExists(macroFile_p):
			if macroFile_p != self._macroFile:
				shutil.copy(macroFile_p, self._macroFile)
		
	def _setDebug(self, debug_p):
		self._debug = debug_p

	def add_accelerator(self, widget, accelerator, signal="activate"):
		"""Adds a keyboard shortcut"""
		if accelerator is not None:
			key, mod = Gtk.accelerator_parse(accelerator)
			widget.add_accelerator(signal, self._accelerators, key, mod, Gtk.AccelFlags.VISIBLE)


	def _createMacroConfirm(self):

		dialog = Gtk.Window( title="Preclicks Manager")
		dialog.set_default_size(500, 60)
		dialog.set_modal(True)
		self._accelerators = Gtk.AccelGroup()
		self._menubar = Gtk.MenuBar()

		self._menubar = Gtk.MenuBar()
		
		self.menu_macro = Gtk.Menu()
		self.item_save = Gtk.MenuItem("_Save As")
		self.item_save.set_use_underline(True)
		self.add_accelerator(self.item_save, "<Control>s","activate")
		self.item_load = Gtk.MenuItem("_Load")
		self.item_load.set_use_underline(True)
		self.add_accelerator(self.item_load, "<Control>o","activate")
		self.item_delete = Gtk.MenuItem("_Unload")
		self.item_delete.set_use_underline(True)
		self.add_accelerator(self.item_delete, "<Control>u","activate")
		self.item_run = Gtk.MenuItem("_Run")
		self.item_run.set_use_underline(True)
		self.add_accelerator(self.item_run, "<Control>n","activate")
		self.menu_macro.append(self.item_save)
		self.menu_macro.append(self.item_load)
		self.menu_macro.append(self.item_delete)
		self.menu_macro.append(self.item_run)
		self.item_save.connect("activate", self._saveMacro, dialog)
		self.item_load.connect("activate", self._onLoadMacro, dialog)
		self.item_delete.connect("activate", self._onDeleteMacro, False)
		self.item_run.connect("activate", self._onRunMacro)
		
		self.menu_help = Gtk.Menu()
		self.item_about = Gtk.MenuItem("_About")
		self.item_about.set_use_underline(True)	
		self.menu_help.append(self.item_about)
		self.item_about.connect("activate", self._onRunAboutDialog, dialog)

		self.item_macro = Gtk.MenuItem("_Macro")
		self.item_macro.set_use_underline(True)
		self.item_help = Gtk.MenuItem("_Help")
		self.item_help.set_use_underline(True)

		self.item_macro.set_submenu(self.menu_macro)
		self.item_help.set_submenu(self.menu_help)

		self._menubar.append(self.item_macro)
		self._menubar.append(self.item_help)

		dialog.add_accel_group(self._accelerators)

		self._labelAutoClickExists = Gtk.Label("Preclicks are existing. What do you want do do with the preclicks?")
		self._labelAutoClickExists.set_selectable(True)

		self._runMacroButton = Gtk.Button(label="_Run")
		self._runMacroButton.set_use_underline(True)
		self._runMacroButton.connect('clicked', self._onRunMacro)

		self._deleteMacroButton = Gtk.Button(label='_Unload')
		self._deleteMacroButton.set_use_underline(True)
		self._deleteMacroButton.connect('clicked', self._onDeleteMacro)

		self._cancelButton = Gtk.Button(label='_Cancel')
		self._cancelButton.set_use_underline(True)
		self._cancelButton.connect('clicked', self._onCancel)

		self._grid = Gtk.Grid()

		dialog.connect("delete-event", self._onCancel)
		dialog.connect('key-release-event', self._onKeyRelease)
		self._grid.attach(self._menubar,0,0,3,1)
		self._grid.attach(self._labelAutoClickExists, 0 , 1, 3, 1)
		self._grid.attach(self._runMacroButton , 0, 2, 1, 1)
		self._grid.attach(self._deleteMacroButton, 1, 2, 1, 1)
		self._grid.attach(self._cancelButton, 2, 2, 1, 1)
		dialog.add(self._grid)
		
		return dialog
	
	def _onRunMacro(self, widget):
		self._gui.hide()
		_thread.start_new_thread( self._threadRunMacro, () )	
		self._cancel(False)
		
	def _onDeleteMacro(self, widget, close_p=True):
		self._deleteMacro()
		if close_p:
			self._cancel(True)

	def _onCancel(self, widget, event=None):
		self._cancel(True)

	def _cancel(self, setMacroFinished):
		if self._gui != None:
			self._gui.hide()
		if setMacroFinished:
			self._MacroFinished = True
		Gtk.main_quit()


	def _macroExists(self):
		return (os.path.exists(self._macroFile) and os.path.isfile(self._macroFile))

	def _loadMacroExists(self, newMacro_p):
		return (os.path.exists(newMacro_p) and os.path.isfile(newMacro_p))

	def _RunMacro(self):
		if not self._macroExists():
			if self._debug:
				print("No Macro loaded..")
			return
		self._MacroFinished = False
		macroFile = open(self._macroFile, "r")
		while 1:
			line = macroFile.readline()
			if not line:
				break
			if self._debug:
				print("_RunMacro: " + line)
			line = line.split(',')
			# doing stuff
			if line[0] == 'c':
				if line[1] == 'delay':
					time.sleep(float(line[2]))

			if line[0] == 'k':
				self._doKeyboardMacroStep(int(line[1]), line[2], int(line[3]))
			if line[0] == 'm':
				self._doMouseMacroStep(int(line[1]), int(line[2]), line[3])
		macroFile.close()
		self._MacroFinished = True
		
	def getMacroFinished(self):
		return self._MacroFinished
		
	def WaitForFinish(self):
		while not self.getMacroFinished() and self._macroExists():
			time.sleep(0.3)
			if self._debug:
				print(self.getMacroFinished())
		time.sleep(0.2)
		self._MacroFinished = False
		if self._debug:
			print("WaitForFinish complete")
		
	def _deleteMacro(self):
		if self._macroExists():
			os.remove(self._macroFile)
	
	def _saveMacro(self, widget, window):
		if not self._macroExists():
			return
		fileDialog = Gtk.FileChooserDialog("Save As", window,Gtk.FileChooserAction.SAVE,("_Cancel",Gtk.ResponseType.CANCEL,"_Save",Gtk.ResponseType.OK))
		fileDialog.set_modal(True)
		fileDialog.set_default_size(800, 400)
		fileDialog.set_local_only(False)
		self.add_filters(fileDialog)
		Gtk.FileChooser.set_current_name(fileDialog, "NewOCRdesktopMakro.ocrm")

		response = fileDialog.run()

		if response == Gtk.ResponseType.OK:
			shutil.copy( self._macroFile, fileDialog.get_filename(),)
		elif response == Gtk.ResponseType.CANCEL:
			pass

		fileDialog.destroy()

	def _onRunAboutDialog(self,widget,window):
		dialog = Gtk.AboutDialog(window)
		dialog.set_authors(__authors__)
		dialog.set_website(__website__)
		dialog.set_copyright(__copyright__)
		dialog.set_license(__license__)
		dialog.set_version(__version__)
		dialog.set_program_name(__appname__)
		dialog.set_comments(__comments__)
		dialog.run()
		dialog.destroy()

	def _onLoadMacro(self, widget, window):
		fileDialog = Gtk.FileChooserDialog("Please choose a file", window,Gtk.FileChooserAction.OPEN,("_Cancel",Gtk.ResponseType.CANCEL,"_Open",Gtk.ResponseType.OK))
		fileDialog.set_modal(True)
		fileDialog.set_default_size(800, 400)
		fileDialog.set_local_only(False)
		self.add_filters(fileDialog)

		response = fileDialog.run()
		if response == Gtk.ResponseType.OK:
			shutil.copy(fileDialog.get_filename(), self._macroFile)
		elif response == Gtk.ResponseType.CANCEL:
			pass

		fileDialog.destroy()

	def add_filters(self, fileDialog):
		filter_text = Gtk.FileFilter()
		filter_text.set_name("Macro Textfiles")
		filter_text.add_mime_type("text/plain")
		filter_text.add_pattern("*.ocrm")
		fileDialog.add_filter(filter_text)

		filter_any = Gtk.FileFilter()
		filter_any.set_name("Any files")
		filter_any.add_pattern("*")
		fileDialog.add_filter(filter_any)

	def _doKeyboardMacroStep(self,keyValue_p, keyString_p, eventType_p = 2):
		"""
		Arguments:
		- keyValue_p: a long integer indicating the keycode or keysym of the key event
			being synthesized.
		- keyString_p: an (optional) UTF-8 string which, if keyval is NULL,
			indicates a 'composed' keyboard input string which is
			being synthesized; this type of keyboard event synthesis does
			not emulate hardware keypresses but injects the string
			as though a composing input method (such as XIM) were used.
		- eventType_p: an AccessibleKeySynthType flag indicating whether keyval
			is to be interpreted as a keysym rather than a keycode
			(pyatspi.KEY_SYM), or whether to synthesize
			KEY_PRESS = 0, KEY_RELEASE = 1, or both (KEY_PRESSRELEASE = 2).
		"""
		if keyValue_p == 0:
			if keyString_p != '':
				keyValue_p = KEY_CODE[keyString_p]
			else:
				if self._debug:
					print("invalid keyboard macro",keyValue_p,keyString_p)
					print("format:")
					print("c, KeyValue, KeyString, eventType")
				return 	
		if eventType_p == 0:
			pyatspi.Registry.generateKeyboardEvent(keyValue_p, keyString_p, pyatspi.KEY_PRESS)
		elif eventType_p == 1:
			pyatspi.Registry.generateKeyboardEvent(keyValue_p, keyString_p, pyatspi.KEY_RELEASE)
		elif eventType_p == 2:
			pyatspi.Registry.generateKeyboardEvent(keyValue_p, keyString_p, pyatspi.KEY_PRESSRELEASE)

	def _doMouseMacroStep(self,xpos, ypos, mouseEvent, posRelation = "abs"):
		pyatspi.Registry.generateMouseEvent(xpos,ypos,posRelation)
		if (mouseEvent != 'None'):
			pyatspi.Registry.generateMouseEvent(xpos,ypos,mouseEvent)
			
	def _threadRunMacro(self):
		if self._debug:
			print("_threadRunMacro starts")
		time.sleep(0.5)
		self._RunMacro()

	def _writeKeyboardToMacro(self, Xpos_p, Ypos_p, MouseEvent_p):
		pass

	def _writeMouseToMacro(self, Xpos_p, Ypos_p, MouseEvent_p):
		macroFile = open(self._macroFile, "a")
		macroFile.write('c,' + 'delay' + ',0.9\n')
		macroFile.write('m,' + str(Xpos_p) + ',' + str(Ypos_p)  + ',' + MouseEvent_p + '\n')
		macroFile.close()

	def showGUI(self):
		if not self._macroExists():
			return

		self._gui = self._createMacroConfirm()
		self._gui.show_all()
		ts = Gtk.get_current_event_time()
		self._gui.present_with_time(ts)
		self._runMacroButton.grab_focus()
		Gtk.main()

	def _onKeyRelease(self, widget, event):
		keycode = event.hardware_keycode
		keymap = Gdk.Keymap.get_default()
		entries_for_keycode = keymap.get_entries_for_keycode(keycode)
		entries = entries_for_keycode[-1]
		eventString = Gdk.keyval_name(entries[0])
		if self._debug:
			print(eventString)
#		if eventString == 'Escape':
#			self._cancel(True)
#		if eventString == 'Return':
#			self._leftClickButton.grab_focus()

if __name__ == "__main__":
	Application = OCRScreenReader()

